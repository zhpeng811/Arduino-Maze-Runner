
#include "util.h"

// Source:
// https://stackoverflow.com/questions/5008804/generating-random-integer-from-a-range
/* Description: generate an random integer number with in the range
                [min,max] (inclusive)
   Args: int min: minimum integer that can be randomly generated
         int max: maximum integer that can be randonly generated
   Returns: int random_integer: randomly integer generated by the 
                                random generator
*/
int randint(int min, int max) {
    random_device rd;     // only used once to initialise (seed) engine
    mt19937 rng(rd());    // random-number engine used (Mersenne-Twister in this case)
    uniform_int_distribution<int> uni(min,max); // guaranteed unbiased

    auto random_integer = uni(rng);

    return random_integer;
}


/* Description: generate an random node using the randint() function
                to generate an random number. And only even identifier
                is allowed, so odd number will be added by 1 to make
                it even.
   Returns: int rand_node: the random node generated with even identifier
*/
int random_node() {
  // node identifiers goes from 0 to half of the maze size minus 2
  int rand_node = randint(0, MAZE_SIZE / 2 - 2);
  // we only have even node(vertex) identifiers
  if (rand_node % 2 != 0) {
    rand_node += 1;
  }

  return rand_node;
}


/* Description: destory the wall between the two nodes by making the
                array at that index equal to 1.
                (we used -1 for wall, anything that is not -1 is a path)
   Args: int vertex: identifier for that vertex
         int nbr: identifier for the neighbour of the vertex
         int &arr[][]: a reference to the maze map
*/
void break_wall(int vertex, int nbr, int (&arr)[MAZE_HEIGHT][MAZE_WIDTH]) {
  int vertex_row, vertex_col, nbr_row, nbr_col;

  // use index mapping to get the row and column index
  // based on the vertex identifier 
  vertex_row = (vertex / MAZE_WIDTH) * 2;
  vertex_col = vertex % MAZE_WIDTH;
  nbr_row = (nbr / MAZE_WIDTH) * 2;
  nbr_col = nbr % MAZE_WIDTH;

  // maze orientation ->  nbr wall vertex
  if (vertex_row == nbr_row && vertex_col > nbr_col) {
    arr[vertex_row][nbr_col + 1] = 1;
  }
  // maze orientation -> vertex wall nbr
  else if(vertex_row == nbr_row && vertex_col < nbr_col) {
    arr[vertex_row][nbr_col - 1] = 1;
  }
  // maze orientation -> nbr
  //                     wall
  //                     vertex
  else if(vertex_col == nbr_col && vertex_row > nbr_row) {
    arr[vertex_row - 1][nbr_col] = 1;
  }
  // maze orientation -> vertex
  //                      wall
  //                      nbr
  else if(vertex_col == nbr_col && vertex_row < nbr_row) {
    arr[vertex_row + 1][nbr_col] = 1;
  }
}
