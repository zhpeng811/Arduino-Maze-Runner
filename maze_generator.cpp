
#include <iostream>
#include <string>

#include "serialport.h"
#include "algorithms.h"

using namespace std;

// initialize a global maze map
int maze_map[MAZE_HEIGHT][MAZE_WIDTH];

/* Description: Default maze map where each node is separated by a wall,
                an 5 x 5 grid example is shown below:

                0  W 2  W 4
                W  W W  W W
                6  W 8  W 10
                W  W W  W W
                12 W 14 W 16
                Note: we only used even number as vertex identifiers,
                      in this case it is easier map the vertex back to
                      the array index.
   Running Time: O(w*h), w = width of the maze, h = height of the maze
*/
void default_maze() {
  int num = 0;
  for (int i = 0; i < MAZE_HEIGHT; i++) {
    for (int j = 0; j < MAZE_WIDTH; j++) {
      // if both index are even, then it contains the vertex identifier 
      if (i % 2 == 0 && j % 2 == 0) {
        maze_map[i][j] = num + j;
      }
      else {
        maze_map[i][j] = -1;
      }
    }

    if (i % 2 == 0) {
      num += MAZE_WIDTH;
    }
  }

}


/* Description: generate a graph of the Digraph class that matches
                the default maze map generated by default_maze() function
   Running Time: O(n), n = half of the maze size
   Args: Digraph& graph: a reference of the graph used to add vertex and edges
*/
void generate_graph(Digraph& graph) {
  for (int i = 0; i < MAZE_SIZE/2; i += 2) {
    graph.addVertex(i);
    // Note: the maze graph is an undirected graph

    // check if the vertex have a left neighbour
    if (i % MAZE_WIDTH != 0) {
        graph.addEdge(i, i-2); 
        graph.addEdge(i-2, i);
    }
    // check if the vertex have a right neighbour
    if ((i - (MAZE_WIDTH - 2)) % MAZE_WIDTH != 0) {
        graph.addEdge(i, i+2);
        graph.addEdge(i+2, i);
    }
    // check if the vertex have a top neighbour
    if (i >= MAZE_WIDTH) {
        graph.addEdge(i, i - MAZE_WIDTH);
        graph.addEdge(i - MAZE_WIDTH, i);
    }
    // check if the vertex have an bottom neighbour
    if (i < MAZE_SIZE/2 - MAZE_WIDTH) {
        graph.addEdge(i, i + MAZE_WIDTH);
        graph.addEdge(i + MAZE_WIDTH, i);
    }
  }
}


/* Description: generate the random maze based on the selected algorithm
   Running Time: depend on the selected algorithm
   Args: int algorithm: algorithm used to generate the maze.
         range from 0 to 2:
         0 - DepthFirstSearch
         1 - Kruskal's Minimum Spanning Tree
         2 - Prim's Minimum Spanning Tree
   Returns: Digraph graph: the graph generated by the generate_graph()
                           function, this graph is needed to find the solution
                           path using solution_graph() and solution_path();
*/
Digraph generate_maze(int algorithm) {
  Digraph graph;
  // initialize the default maze and the default graph
  default_maze();
  generate_graph(graph);
  // randomly generate a node, only DFS and Prim will
  // need a random starting node
  int rand_node = random_node();
  if (algorithm == 0) {
    queue<int> Q;
    unordered_map<int,int> visited;
    Maze_DFS(graph, rand_node, visited, Q, maze_map);
  }
  else if (algorithm == 1) {
    Kruskal_MST(graph, maze_map);
  }
  else if (algorithm == 2) {
    Prim_MST(graph, rand_node, maze_map);
  }
  return graph;
}


/* Description: get the graph after the maze have been generated,
                so the graph only contains edges that are paths in the maze.
   Running Time: O(|E|), |E| is the number of edges in the default maze graph
   Args: Digraph& graph: a reference of the default maze graph
   Return: Digraph maze_graph: maze graph which only contain edges that 
                               are paths in the maze.
*/
Digraph solution_graph(Digraph& graph) {
  Digraph maze_graph;
  vector<PII> edge = graph.edges();
  int v, nbr, v_row, v_col, nbr_row, nbr_col;
  bool iswall = true;

  // loop through all edges to check which edges contains
  // a path in the maze map
  for (auto iter = edge.begin(); iter != edge.end(); iter++) {
    iswall = true;

    // get the vertex and nbr and map it to the corrsponding
    // index in the maze map
    // the procedure is similar to the break_wall function
    // in "util.cpp"
    v = iter->first;
    nbr = iter->second;
    v_row = (v / MAZE_WIDTH) * 2;
    v_col = v % MAZE_WIDTH;
    nbr_row = (nbr / MAZE_WIDTH) * 2;
    nbr_col = nbr % MAZE_WIDTH;

    // check if there is a wall between the vertex and neighbour
    if (v_row == nbr_row && v_col > nbr_col) {
      if (maze_map[v_row][nbr_col + 1] != -1) {
        iswall = false;
      }
    }
    else if(v_row == nbr_row && v_col < nbr_col) {
      if (maze_map[v_row][nbr_col - 1] != -1) {
        iswall = false;
      }
    }
    else if(v_col == nbr_col && v_row > nbr_row) {
      if (maze_map[v_row - 1][nbr_col] != -1) {
        iswall = false;
      }
    }
    else if(v_col == nbr_col && v_row < nbr_row) {
      if (maze_map[v_row + 1][nbr_col] != -1) {
        iswall = false;
      }
    }

    // add the edge to the graph if the vertex and neighbour
    // is not separated by a wall
    if (!iswall) {
      maze_graph.addEdge(v,nbr);
    }
  }

  return maze_graph;
}


/* Description: get the solution path by stepping from the end vertex of the
                searchTree to the start vertex
   Running Time: O(n), n = number of nodes from start vertex to end vertex
   Args: list<int>& path: a reference to the path used to store solution path
         unordered_map<int, int> tree: the search_tree constructed from BFS.
         int start: start vertex
         int end: end vertex
*/
void solution_path(list<int>& path, unordered_map<int,int> tree, int start, int end) {
    int stepping = end;
    path.clear();
    while (stepping != start) {
        path.push_front(stepping);
        stepping = tree[stepping];
    }
    path.push_front(start);
}


/* Description: wait for the acknowledgement character 'A' from client.
   Args: SerialPort* SerialP: a pointer to the SerialPort class
         int timeout: timeout specified in milliseconds
   Returns: true if the acknowledgement recieved.
            false if timeout or the recieved message is not 'A'.
*/
bool wait_for_acknowledgement(SerialPort* SerialP, int timeout) {
  string acknowledge = SerialP->readline(timeout);

  // if nothing is recieved in the specified timeout period
  if (acknowledge.size() == 0) {
      return false;
  }
  if (acknowledge.front() == 'A') {
      return true;
  }
  else {
      return false;
  }
}


/* Description: send the maze map row by row to the client, after
                each row is send, the server will wait for an 
                acknowledgement from the client
   Running Time: O(w*h), w = width of the maze, h = height of the maze
   Args: SerialPort* SerialP: a pointer to the SerialPort class
         int timeout: timeout specified in milliseconds
*/
void send_mazemap(SerialPort* SerialP, int timeout) {
  string line = "";

  for (int i = 0; i < MAZE_HEIGHT; i++) {
    for (int j = 0; j < MAZE_WIDTH; j++) {
      if (maze_map[i][j] == -1) {
        line += "0 "; // we use 0 to represent the wall
      }
      else {
        line += "1 "; // we use 1 to represent the path
      }
    }

    line += "\n";
    SerialP->writeline(line);

    // wait for an 'A' from the client, terminate the function
    // if 'A' is not recieved within the timeout period
    if ( !wait_for_acknowledgement(SerialP, timeout) ) {
      return;
    }
    line = ""; // reset the string for the next row
  }

}


/* Description: get and send the solution of the current maze that
                the client is running.
   Args: SerialPort* SerialP: a pointer to the SerialPort class
         Digraph graph: default maze graph
         int timeout: timeout specified in milliseconds
*/
void send_solution(SerialPort* SerialP, Digraph graph, int timeout) {
  Digraph sol_graph;
  list<int> sol_path;
  unordered_map<int,int> sol_tree;
  string numpoints, vertex;

  // obtain the solution graph, tree and path
  sol_graph = solution_graph(graph);
  BreadthFirstSearch(sol_graph, 0, sol_tree);
  solution_path(sol_path, sol_tree, 0, 598);

  // send the number of waypoints to the client
  numpoints = to_string(sol_path.size()) + '\n';
  SerialP->writeline(numpoints);

  if ( !wait_for_acknowledgement(SerialP, timeout) ) {
    return;
  }

  // send all vertex information to the client
  for (auto iter = sol_path.begin(); iter != sol_path.end(); iter++) {
    vertex = to_string(*iter) + '\n';
    SerialP->writeline(vertex);
    if ( !wait_for_acknowledgement(SerialP, timeout) ) {
      return;
    }
  }
}


int main() {
  // use a pointer to ensure the serial port function
  // writeline() and readline() operate correctly
  SerialPort Serial("/dev/ttyACM0");
  SerialPort* SerialP = &Serial;
  string request;
  Digraph graph;
  int algorithm;
  // for server, a timeout of 1 second is used for all communications
  int timeout = 1000; 

  while (true) {
    algorithm = -1;

    // continue to read until it recieves an message from the serial port
    do {
      request = SerialP->readline();
    } while (request == "");

    if (request.front() == 'D') { // DepthFirstSearch
      algorithm = 0;
    }
    else if (request.front() == 'K') { // Kruskal's Minimum Spanning Tree
      algorithm = 1;
    }
    else if (request.front() == 'P') { // Prim's Minimum Spanning Tree
      algorithm = 2;
    }
    else if (request.front() == 'S') { // Client requested for solution
      send_solution(SerialP, graph, timeout);
    }

    if (algorithm >= 0 && algorithm <= 2) {
      graph = generate_maze(algorithm);
      send_mazemap(SerialP, timeout);
    }
    // if timeout occurs in send_solution() or send_mazemap()
    // server will automatically go back to wait for another request
  }

  return 0;
}
